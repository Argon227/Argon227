//в заголовочном файле (файл - содержимое которого автоматически добавляется препроцессором в исходный текст в том месте, где располагается соотв. директива)
//пишем интерфейс класса - в c++ - чисто астрактный класс (т. е. класс, не содержащий данных и определенных методов),
//реализуемый в других файлах проекта с помощью директивы #include "lab5.h" путём наследования этого абстрактного класса;
#pragma once
#ifndef LAB_5//Данная препроцессорная обёртка предотвращает попытку многократного включения заголовочных файлов. 
//Препроцессорные директивы обрабатываются до этапа компиляции, программой-препроцессором, и не допускают многократного 
//определения одного и того же класса (директива #ifndef проверяет, определено ли имя LAB_5, если нет, то управление передаётся директиве 
//#define и определяется интерфейс класса. Если же имя LAB_5 уже определено, управление передаётся директиве #endif. Таким образом, 
//исключается возможность многократного определения класса Matrix.

#define LAB_5
#include <iostream>//содержит два основных класса: cin — для обработки ввода с клавиатуры;
//cout — для вывода в консоль переменных или просто текста (содержат операторы перенаправления форматированного вывода << и >>;

#include <fstream>//содержит классы ifstream и ofstream для для считывания данных из файла и для записи в файл;

#include <cassert>



using namespace std;//подключение станд. пр-ва имен;



class Matrix {

private:

	int **arr;//указатель на указатель - первый указатель содержит адрес второго, 
	//который в свою очередь содержит адрес участка памяти, содержащего некоторое значение
	// (исп. при иницализации многомерных массивов) (теория:  переменная — это название кусочка памяти, который содержит значение. 
	//При выполнении инициализации переменной, ей автоматически присваивается свободный адрес памяти, и любое значение, которое мы 
	//присваиваем переменной, сохраняется в этом адресе памяти. оператор адреса & - позволяет узнать, какой адрес памяти присвоен переменной.
	//оператор разименования * -  позволяет получить значение по определенному адресу; указатель — это переменная, значением которой является адрес памяти.

	int rows;

	int columns;

public:

	Matrix();

	Matrix(int row, int cols);

	~Matrix();

	int Rows();

	int Columns();

	int Element(int i, int j);

	void Read(string filename);

	void Print();

	Matrix operator+(Matrix& other)const;

	Matrix operator-(Matrix& other)const;

	Matrix operator*(Matrix& other)const;

	Matrix Transp()const;

	Matrix operator=(Matrix& other)const;

	bool operator==(Matrix& other)const;

	friend ostream& operator<<(ostream& os, const Matrix& other);//дружественная функция - функция, которая не является членом класса, 
	//но имеет доступ к членам класса, объявленным в полях private или protected. Так как она не является компонентом класса, она не 
	//получает указатель this. Вызываются дружественные функции, как обычные функции. Имеется одна ситуация, в которой необходимо использо­вать 
	//дружественные функции. Указатель на объект, вызывающий функцию-оператор, передается в указателе this. В случае бинарных операторов левый 
	//объект вызывает эту фун­кцию. Такой способ работает до тех пор, пока левый объект определяет заданную операцию (т. е. для объекта O {O+10}-
	//-будет работать, {10+O} - не будет работать, т. к. теперь слева - стоит целое число, являющееся встроенным типом и не имеет функции для сложения
	// с объектом O). Поэтому операторы ввода и вывода при их перегрузке лучше делать дружесвенными (при вводе слева может быть сторка или символ - встроенные типы);

	friend istream& operator>>(istream& is, Matrix& other);
};

#endif LAB_5
